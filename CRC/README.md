## Побитовый сдвиг
Этот метод реализует вычисление контрольной суммы путём последовательного сдвига и исключающего ИЛИ (XOR). Это классический алгоритм CRC, подходящий для понимания внутреннего устройства процедуры проверки циклического избыточного кода.
```cpp
uint8_t crc8(uint8_t* data, size_t len) {
    uint8_t crc = 0;
    for(size_t i = 0; i < len; ++i) {
        crc ^= data[i];
        for(int j = 0; j < 8; ++j) {
            if(crc & 0x80) { // старший бит установлен?
                crc <<= 1;
                crc ^= 0xD5; // XOR с полиномом
            }
            else {
                crc <<= 1;
            }
        }
    }
    return crc;
}
```
## Табличный метод
Таблица предварительно рассчитанных значений ускоряет процесс расчёта контрольной суммы, особенно для больших объёмов данных. Вместо побитовых операций мы используем заранее подготовленную таблицу, соответствующую каждому возможному значению байта.

```cpp
uint8_t crc8_tab(uint8_t* data, size_t len) {
    uint8_t crc = 0;
    for(size_t i = 0; i < len; ++i) {
        crc = crc8_table[(crc ^ data[i])]; // Использование предрассчитанной таблицы
    }
    return crc;
}
```

# Анализ результатов
## Закодированный "Test string"
<img width="377" height="119" alt="image" src="https://github.com/user-attachments/assets/bc4d003e-b2e2-4615-9d62-787ac2797978" />

1) Метод побитового сдвига: подходит для малых объемов данных, даёт точное понимание процесса расчёта CRC, однако менее эффективен на крупных объёмах данных.
2) Табличный метод: значительно быстрее благодаря предварительной подготовке таблиц, лучше масштабируется на большие массивы данных.
